* Hey! If you're reading this on Github, you should download this file instead. Github doesn't display org-babel files very well.

by Peixian Wang - 2016/8/3

/This is licensed under MIT, so do what you want with it, modify it, fork it, etc. If you use this code I'd apprechiate an attribution back :>/

*MAKE SURE YOU'RE IN THE RIGHT VIRTUALENV*
*** Setup
Import the supporting cast
#+BEGIN_SRC ipython :session 
  import collectobot
  import yaha_analyzer
  import pandas as pd
  import numpy as np
#+END_SRC

#+RESULTS:


#+BEGIN_SRC ipython :session :results output
  df = pd.read_json('../data/cards.json')
  print(df.head(3))
  print(df.columns)
#+END_SRC

#+RESULTS:
#+begin_example
  artist  attack  collectible  cost  durability dust entourage faction flavor  \
0    NaN     0.0          NaN   0.0         NaN  NaN       NaN     NaN    NaN   
1    NaN     NaN          NaN   2.0         NaN  NaN       NaN     NaN    NaN   
2    NaN     1.0          NaN   1.0         NaN  NaN       NaN     NaN    NaN   

   health     ...     overload  \
0     2.0     ...          NaN   
1     NaN     ...          NaN   
2     1.0     ...          NaN   

                                    playRequirements playerClass    race  \
0                                                NaN      SHAMAN     NaN   
1  {'REQ_MINION_OR_ENEMY_HERO': 0, 'REQ_STEADY_SH...      HUNTER     NaN   
2                                                NaN     NEUTRAL  DRAGON   

  rarity         set spellDamage targetingArrowText  \
0    NaN         TGT         NaN                NaN   
1   FREE  HERO_SKINS         NaN                NaN   
2    NaN         BRM         NaN                NaN   

                                                text        type  
0                             <b>Spell Damage +1</b>      MINION  
1  <b>Hero Power</b>\nDeal $2 damage to the enemy...  HERO_POWER  
2                                                NaN      MINION  

[3 rows x 25 columns]
Index(['artist', 'attack', 'collectible', 'cost', 'durability', 'dust',
       'entourage', 'faction', 'flavor', 'health', 'howToEarn',
       'howToEarnGolden', 'id', 'mechanics', 'name', 'overload',
       'playRequirements', 'playerClass', 'race', 'rarity', 'set',
       'spellDamage', 'targetingArrowText', 'text', 'type'],
      dtype='object')
#+end_example


Filter out all the weird generated cards:
#+BEGIN_SRC ipython :session :results output
  df = df[df['collectible'] == 1.0]
  df = df[pd.notnull(df['cost'])]
#+END_SRC

#+RESULTS:
*** Normalize the cost, attack, and health
#+BEGIN_SRC ipython :session :results output
  from sklearn import preprocessing

  df[['attack', 'health']] = df[['attack', 'health']].fillna(0) #Fill the spells with 0 attack and 0 health to normalize (there's probably a better way of doing this)

  min_max_scaler = preprocessing.MinMaxScaler()
  norm = lambda x: min_max_scaler.fit_transform(x)
  df_n_stats = df[['id', 'attack', 'cost', 'health']]
  df_n_stats[['attack', 'cost', 'health']] = df_n_stats[['attack', 'cost', 'health']].apply(norm)
  print(df_n_stats.head(5))
#+END_SRC

#+RESULTS:
:          id    attack  cost    health
: 3    OG_121  0.583333  0.28  0.466667
: 6    OG_085  0.166667  0.16  0.266667
: 10   AT_076  0.250000  0.16  0.266667
: 15  CS2_124  0.250000  0.12  0.066667
: 17  GVG_079  0.583333  0.32  0.466667

*** Coerce the mechanics into binary features with one hot encoding
#+BEGIN_SRC ipython :session :results output
  df_mechanics = df[['id','mechanics', 'overload', 'spellDamage']] #weirdly overload isn't a listed mechanic, check bug: https://github.com/HearthSim/HearthstoneJSON/issues/35
  for i, row in df_mechanics.iterrows():
      val = row['mechanics']
      overload = row['overload']
      spell_damage = row['spellDamage']
      #hey look kids let's violate DRY today!
      if pd.notnull(overload):
          if isinstance(val, list) and 'OVERLOAD' not in val:
              val.append('OVERLOAD')
          elif not isinstance(val, list):
              val = ['OVERLOAD']
      if pd.notnull(spell_damage):
          if isinstance(val, list) and 'SPELL_DAMAGE' not in val:
              val.append('SPELL_DAMAGE')
          elif not isinstance(val, list):
              val = ['SPELL_DAMAGE']
      if not isinstance(val, list) and pd.isnull(overload) and pd.isnull(spell_damage):
          val = ['NONE']
      df_mechanics.set_value(i, 'mechanics', val)
  df_mechanics.drop('overload', axis=1, inplace=True)
  df_mechanics.drop('spellDamage', axis=1, inplace=True)
  import sklearn
  from sklearn.preprocessing import MultiLabelBinarizer
  from sklearn.preprocessing import OneHotEncoder
  mlbin = MultiLabelBinarizer()
  binarized = mlbin.fit_transform(df_mechanics['mechanics']) #transform into a matrix of integers
  enc = sklearn.preprocessing.OneHotEncoder() #binarize and encode
  encoded = enc.fit_transform(binarized)

  df_mechanics['mechanics_binarized'] = binarized.tolist()
  df_mechanics['mechanics_sparse'] = encoded
  print(mlbin.classes_)
  print(df_mechanics.head(5))
  #print(df_mechanics.dtypes) #[id, mechanics, mechanics_binarized, sparse] -> [string, list, list, scipi csr]
#+END_SRC

#+RESULTS:
#+begin_example
['ADJACENT_BUFF' 'AURA' 'BATTLECRY' 'CANT_ATTACK'
 'CANT_BE_TARGETED_BY_ABILITIES' 'CANT_BE_TARGETED_BY_HERO_POWERS' 'CHARGE'
 'CHOOSE_ONE' 'COMBO' 'DEATHRATTLE' 'DIVINE_SHIELD' 'ENRAGED' 'FORGETFUL'
 'FREEZE' 'INSPIRE' 'ImmuneToSpellpower' 'InvisibleDeathrattle' 'NONE'
 'OVERLOAD' 'POISONOUS' 'RITUAL' 'SECRET' 'SILENCE' 'SPELL_DAMAGE'
 'STEALTH' 'TAUNT' 'TOPDECK' 'WINDFURY']
         id        mechanics  \
3    OG_121      [BATTLECRY]   
6    OG_085           [NONE]   
10   AT_076        [INSPIRE]   
15  CS2_124         [CHARGE]   
17  GVG_079  [DIVINE_SHIELD]   

                                  mechanics_binarized  \
3   [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...   
6   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...   
10  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, ...   
15  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, ...   
17  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, ...   

                                     mechanics_sparse  
3     (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...  
6     (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...  
10    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...  
15    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...  
17    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...  
#+end_example

*** Binarize and encode the playerClass 
#+BEGIN_SRC ipython :session :results output
  df_player_class = df[['id', 'playerClass']]
  df_player_class['playerClass'].fillna('Neutral', inplace=True)

  from sklearn.preprocessing import LabelBinarizer
  mlbin = LabelBinarizer()
  binarized = mlbin.fit_transform(df_player_class['playerClass'])
  enc = sklearn.preprocessing.OneHotEncoder()
  encoded = enc.fit_transform(binarized)

  df_player_class['player_class_binarized'] = binarized.tolist()
  df_player_class['player_class_sparse'] = encoded
  print(mlbin.classes_)
  print(df_player_class.head(5))
#+END_SRC

#+RESULTS:
#+begin_example
['DRUID' 'HUNTER' 'MAGE' 'NEUTRAL' 'PALADIN' 'PRIEST' 'ROGUE' 'SHAMAN'
 'WARLOCK' 'WARRIOR']
         id playerClass          player_class_binarized  \
3    OG_121     WARLOCK  [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]   
6    OG_085        MAGE  [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]   
10   AT_076     PALADIN  [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]   
15  CS2_124     NEUTRAL  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]   
17  GVG_079     NEUTRAL  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]   

                                  player_class_sparse  
3     (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...  
6     (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...  
10    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...  
15    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...  
17    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...  
#+end_example

*** Binarize and encode the rarity 
#+BEGIN_SRC ipython :session :results output
  df_rarity = df[['id', 'rarity']]
  mlbin = LabelBinarizer()
  binarized = mlbin.fit_transform(df_rarity['rarity'])
  enc = sklearn.preprocessing.OneHotEncoder()
  encoded = enc.fit_transform(binarized)

  df_rarity['rarity_binarized'] = binarized.tolist()
  df_rarity['rarity_sparse'] = encoded
  print(mlbin.classes_)
  print(df_rarity.head(5))
  print(type(df_rarity['rarity_sparse'][3]))
#+END_SRC

#+RESULTS:
#+begin_example
['COMMON' 'EPIC' 'FREE' 'LEGENDARY' 'RARE']
         id     rarity rarity_binarized  \
3    OG_121  LEGENDARY  [0, 0, 0, 1, 0]   
6    OG_085       RARE  [0, 0, 0, 0, 1]   
10   AT_076     COMMON  [1, 0, 0, 0, 0]   
15  CS2_124       FREE  [0, 0, 1, 0, 0]   
17  GVG_079     COMMON  [1, 0, 0, 0, 0]   

                                        rarity_sparse  
3     (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
6     (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
10    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
15    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
17    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
<class 'scipy.sparse.csr.csr_matrix'>
#+end_example

# *** Binarize and encode the play requirements
# Condense each dictionary into a list of strings with "{key}_{val}"
# #+BEGIN_SRC ipython :session 
#   df_play_requirements = df[['id', 'playRequirements']]
#   #df_play_requirements['playRequirements'].fillna(0, inplace=True)
#   df_play_requirements['playRequirements'] = df_play_requirements[pd.notnull(df['playRequirements'])]['playRequirements'].apply(lambda x: [(k,v) for k,v in x.items()])
#   print(df_play_requirements)
# #+END_SRC

# #+RESULTS:

*** Join the dataframes together
#+BEGIN_SRC ipython :session :results output
  df_combined = df_n_stats.merge(df_mechanics, on='id')
  df_combined = df_combined.merge(df_player_class, on='id')
  df_combined = df_combined.merge(df_rarity, on='id')
  print(df_combined.head(5))
#+END_SRC

#+RESULTS:
#+begin_example
        id    attack  cost    health        mechanics  \
0   OG_121  0.583333  0.28  0.466667      [BATTLECRY]   
1   OG_085  0.166667  0.16  0.266667           [NONE]   
2   AT_076  0.250000  0.16  0.266667        [INSPIRE]   
3  CS2_124  0.250000  0.12  0.066667         [CHARGE]   
4  GVG_079  0.583333  0.32  0.466667  [DIVINE_SHIELD]   

                                 mechanics_binarized  \
0  [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...   
1  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...   
2  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, ...   
3  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, ...   
4  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, ...   

                                    mechanics_sparse playerClass  \
0    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...     WARLOCK   
1    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...        MAGE   
2    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...     PALADIN   
3    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...     NEUTRAL   
4    (0, 54)\t1.0\n  (0, 52)\t1.0\n  (0, 50)\t1.0...     NEUTRAL   

           player_class_binarized  \
0  [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]   
1  [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]   
2  [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]   
3  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]   
4  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]   

                                 player_class_sparse     rarity  \
0    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...  LEGENDARY   
1    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...       RARE   
2    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...     COMMON   
3    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...       FREE   
4    (0, 18)\t1.0\n  (0, 17)\t1.0\n  (0, 14)\t1.0...     COMMON   

  rarity_binarized                                      rarity_sparse  
0  [0, 0, 0, 1, 0]    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
1  [0, 0, 0, 0, 1]    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
2  [1, 0, 0, 0, 0]    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
3  [0, 0, 1, 0, 0]    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
4  [1, 0, 0, 0, 0]    (0, 8)\t1.0\n  (0, 7)\t1.0\n  (0, 4)\t1.0\n ...  
#+end_example

Pass it into spark
#+BEGIN_SRC ipython :session :results output
  import findspark
  findspark.init('/Users/peixianwang/Code/spark-2.0.0')
  import pyspark
  from pyspark.sql import SparkSession
  context = pyspark.SparkContext(appName = 'hs2vec') #Spark variables are camelcase for whatever reason
  spark = SparkSession(context)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session :results output
  transpose_to_csc = lambda x: x.tocsc()
  df_combined[['mechanics_sparse', 'player_class_sparse', 'rarity_sparse']] = df_combined[['mechanics_sparse','player_class_sparse', 'rarity_sparse']].applymap(lambda x: x.tocsc())
  print(df_combined.dtypes)
  #df_sparse = df_combined[['mechanics_sparse', 'player_class_sparse', 'rarity_sparse']].apply(lambda x: x.tocsc(), axis=0)
  #combined_spark_df = spark.createDataFrame(df_combined)
#+END_SRC

#+RESULTS:
#+begin_example
id                         object
attack                    float64
cost                      float64
health                    float64
mechanics                  object
mechanics_binarized        object
mechanics_sparse           object
playerClass                object
player_class_binarized     object
player_class_sparse        object
rarity                     object
rarity_binarized           object
rarity_sparse              object
features                   object
dtype: object
#+end_example

*** Pass into TSNE
#+BEGIN_SRC ipython :session :results output 
  from sklearn.decomposition import PCA
  from scipy.sparse import hstack
  df_combined['features'] = df_combined[['attack', 'cost', 'health']].values.tolist()
  for i, row in df_combined.iterrows():
      val = row['features']
      val.extend(row['mechanics_binarized'])
      val.extend(row['player_class_binarized'])
      val.extend(row['rarity_binarized'])
      df_combined.set_value(i, 'features', val)
  print(df_combined.head(5))
  print(len(df_combined['features'][0]))
#+END_SRC

#+RESULTS:
#+begin_example
        id    attack  cost    health        mechanics  \
0   OG_121  0.583333  0.28  0.466667      [BATTLECRY]   
1   OG_085  0.166667  0.16  0.266667           [NONE]   
2   AT_076  0.250000  0.16  0.266667        [INSPIRE]   
3  CS2_124  0.250000  0.12  0.066667         [CHARGE]   
4  GVG_079  0.583333  0.32  0.466667  [DIVINE_SHIELD]   

                                 mechanics_binarized  \
0  [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...   
1  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...   
2  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, ...   
3  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, ...   
4  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, ...   

                                    mechanics_sparse playerClass  \
0    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...     WARLOCK   
1    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...        MAGE   
2    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...     PALADIN   
3    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...     NEUTRAL   
4    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...     NEUTRAL   

           player_class_binarized  \
0  [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]   
1  [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]   
2  [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]   
3  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]   
4  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]   

                                 player_class_sparse     rarity  \
0    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...  LEGENDARY   
1    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...       RARE   
2    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...     COMMON   
3    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...       FREE   
4    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (2, 0)\t1.0\n ...     COMMON   

  rarity_binarized                                      rarity_sparse  \
0  [0, 0, 0, 1, 0]    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (3, 0)\t1.0\n ...   
1  [0, 0, 0, 0, 1]    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (3, 0)\t1.0\n ...   
2  [1, 0, 0, 0, 0]    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (3, 0)\t1.0\n ...   
3  [0, 0, 1, 0, 0]    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (3, 0)\t1.0\n ...   
4  [1, 0, 0, 0, 0]    (0, 0)\t1.0\n  (1, 0)\t1.0\n  (3, 0)\t1.0\n ...   

                                            features  
0  [0.5833333333333333, 0.28, 0.4666666666666667,...  
1  [0.16666666666666666, 0.16, 0.2666666666666666...  
2  [0.25, 0.16, 0.26666666666666666, 0, 0, 0, 0, ...  
3  [0.25, 0.12, 0.06666666666666667, 0, 0, 0, 0, ...  
4  [0.5833333333333333, 0.32, 0.4666666666666667,...  
46
#+end_example

#+BEGIN_SRC ipython :session :file tmp/out.png :exports both
  from sklearn.manifold import TSNE
  #tnse_model = TSNE(n_components=dimensions, n_iter=10000000, metric="correlation", learning_rate=50, early_exaggeration=500.0, perplexity=40.0)
  tnse_model = TSNE(n_components = 3)
  np.set_printoptions(suppress=True)
  model = tnse_model.fit_transform(df_combined['features'].tolist())
#+END_SRC

#+BEGIN_SRC ipython :session :results output
  df_plot = pd.DataFrame(model)
  df_plot.columns = ['x', 'y', 'z']
  df_plot['labels'] = list(map(lambda x: df[df['id'] == x]['name'].values[0], df_combined['id']))
  df_plot['rarity'] = list(map(lambda x: df[df['id'] == x]['rarity'].values[0], df_combined['id']))
  print(df_plot.head(5))
  print(df_plot['rarity'].unique())
#+END_SRC

#+RESULTS:
:            x          y          z                labels     rarity
: 0  -4.479049  15.257524  -0.774990              Cho'gall  LEGENDARY
: 1   7.489447  -4.172462  -0.489368  Demented Frostcaller       RARE
: 2   5.430795  -7.699553   5.059074         Murloc Knight     COMMON
: 3   1.909211  -0.061407  14.770687             Wolfrider       FREE
: 4 -10.121653  -5.690847   7.774955        Force-Tank MAX     COMMON
: ['LEGENDARY' 'RARE' 'COMMON' 'FREE' 'EPIC']


*** Create plotly graph
#+BEGIN_SRC ipython :session :file  :exports both
  import plotly.plotly as py
  import plotly.graph_objs as go

  colors = {'LEGENDARY': '#F535A5', 'RARE': '#3993F9', 'EPIC': '#CC47D5', 'COMMON': '#F3F9F1', 'FREE': '#263238' }
  traces = []
  clusters = []
  for rarity in df_plot['rarity'].unique():
      df_filtered = df_plot[df_plot['rarity'] == rarity]
      trace = go.Scatter3d(
          type = "scatter3d",
          x = df_filtered['x'],
          y = df_filtered['y'],
          z = df_filtered['z'],
          mode = 'markers',
          name = rarity,
          text = df_filtered['labels'],
          marker = dict(
              color = colors[rarity]
          )
      )
      traces.append(trace)
      cluster = dict(
          alphahull = 7,
          name = rarity,
          opacity = 0.1,
          type = "mesh3d",
          x = df_filtered['x'], y = df_filtered['y'], z = df_filtered['z']
      )
      traces.append(cluster)
  empty_axis = dict(zeroline=False, showaxeslabels=False, showticklabels=False, title='')
  layout = go.Layout(
      margin=dict(
          l=0,
          r=0,
          b=0,
          t=0
      ),
      scene = dict(
        xaxis = empty_axis,
        yaxis = empty_axis,
        zaxis = empty_axis
    )
  )
  #print(clusters[:2])
  fig = go.Figure(data = traces, layout=layout)
  py.plot(fig)
#+END_SRC

#+RESULTS:
: 'https://plot.ly/~sekki/26'




* Spark stuff

#+RESULTS:

#+BEGIN_SRC ipython :session :results output
  df = spark.read.json('../data/cards.json')
  print(df_hsjson.printSchema())
#+END_SRC

#+RESULTS:
#+begin_example
root
 |-- artist: string (nullable = true)
 |-- attack: long (nullable = true)
 |-- collectible: boolean (nullable = true)
 |-- cost: long (nullable = true)
 |-- durability: long (nullable = true)
 |-- dust: array (nullable = true)
 |    |-- element: long (containsNull = true)
 |-- entourage: array (nullable = true)
 |    |-- element: string (containsNull = true)
 |-- faction: string (nullable = true)
 |-- flavor: string (nullable = true)
 |-- health: long (nullable = true)
 |-- howToEarn: string (nullable = true)
 |-- howToEarnGolden: string (nullable = true)
 |-- id: string (nullable = true)
 |-- mechanics: array (nullable = true)
 |    |-- element: string (containsNull = true)
 |-- name: string (nullable = true)
 |-- overload: long (nullable = true)
 |-- playRequirements: struct (nullable = true)
 |    |-- REQ_DAMAGED_TARGET: long (nullable = true)
 |    |-- REQ_ENEMY_TARGET: long (nullable = true)
 |    |-- REQ_ENEMY_WEAPON_EQUIPPED: long (nullable = true)
 |    |-- REQ_ENTIRE_ENTOURAGE_NOT_IN_PLAY: long (nullable = true)
 |    |-- REQ_FRIENDLY_MINION_DIED_THIS_GAME: long (nullable = true)
 |    |-- REQ_FRIENDLY_TARGET: long (nullable = true)
 |    |-- REQ_HERO_TARGET: long (nullable = true)
 |    |-- REQ_LEGENDARY_TARGET: long (nullable = true)
 |    |-- REQ_MINIMUM_ENEMY_MINIONS: long (nullable = true)
 |    |-- REQ_MINIMUM_TOTAL_MINIONS: long (nullable = true)
 |    |-- REQ_MINION_CAP_IF_TARGET_AVAILABLE: long (nullable = true)
 |    |-- REQ_MINION_OR_ENEMY_HERO: long (nullable = true)
 |    |-- REQ_MINION_TARGET: long (nullable = true)
 |    |-- REQ_MUST_TARGET_TAUNTER: long (nullable = true)
 |    |-- REQ_NONSELF_TARGET: long (nullable = true)
 |    |-- REQ_NUM_MINION_SLOTS: long (nullable = true)
 |    |-- REQ_STEADY_SHOT: long (nullable = true)
 |    |-- REQ_TARGET_FOR_COMBO: long (nullable = true)
 |    |-- REQ_TARGET_IF_AVAILABLE: long (nullable = true)
 |    |-- REQ_TARGET_IF_AVAILABLE_AND_DRAGON_IN_HAND: long (nullable = true)
 |    |-- REQ_TARGET_IF_AVAILABLE_AND_MINIMUM_FRIENDLY_MINIONS: long (nullable = true)
 |    |-- REQ_TARGET_MAX_ATTACK: long (nullable = true)
 |    |-- REQ_TARGET_MIN_ATTACK: long (nullable = true)
 |    |-- REQ_TARGET_TO_PLAY: long (nullable = true)
 |    |-- REQ_TARGET_WITH_RACE: long (nullable = true)
 |    |-- REQ_UNDAMAGED_TARGET: long (nullable = true)
 |    |-- REQ_WEAPON_EQUIPPED: long (nullable = true)
 |-- playerClass: string (nullable = true)
 |-- race: string (nullable = true)
 |-- rarity: string (nullable = true)
 |-- set: string (nullable = true)
 |-- spellDamage: long (nullable = true)
 |-- targetingArrowText: string (nullable = true)
 |-- text: string (nullable = true)
 |-- textInPlay: string (nullable = true)
 |-- type: string (nullable = true)

None
#+end_example

Filter out the weird not-player cards
#+BEGIN_SRC ipython :session :results output
  df = df.filter(df['playerClass'] != 'null')
  df = df.filter(df['cost'] == 'null')
  df.show(5)
#+END_SRC

#+RESULTS:
#+begin_example
+--------------------+------+-----------+----+----------+--------------------+---------+-------+--------------------+------+--------------------+--------------------+-------+-------------+------------+--------+--------------------+-----------+-----+---------+-------+-----------+------------------+--------------------+----------+------+
|              artist|attack|collectible|cost|durability|                dust|entourage|faction|              flavor|health|           howToEarn|     howToEarnGolden|     id|    mechanics|        name|overload|    playRequirements|playerClass| race|   rarity|    set|spellDamage|targetingArrowText|                text|textInPlay|  type|
+--------------------+------+-----------+----+----------+--------------------+---------+-------+--------------------+------+--------------------+--------------------+-------+-------------+------------+--------+--------------------+-----------+-----+---------+-------+-----------+------------------+--------------------+----------+------+
|Alex Horley Orlan...|  null|       true|   3|      null|                null|     null|   null|"I've just sucked...|  null|Unlocked at Level 1.|Unlocked at Level...|CS2_061|         null|  Drain Life|    null|[null,null,null,n...|    WARLOCK| null|     FREE|   CORE|       null|              null|Deal $2 damage. R...|      null| SPELL|
|        Raven Mimura|  null|       true|   3|      null|    [40, 400, 5, 50]|     null|   null|Generally demons ...|  null|                null|                null|EX1_317|         null|Sense Demons|    null|                null|    WARLOCK| null|   COMMON|EXPERT1|       null|              null|Put 2 random Demo...|      null| SPELL|
|Alex Horley Orlan...|     1|       true|   4|      null|[400, 1600, 100, ...|     null|   null|Crescendo himself...|     1|                null|                null| AT_019|[DEATHRATTLE]|  Dreadsteed|    null|                null|    WARLOCK|DEMON|     EPIC|    TGT|       null|              null|<b>Deathrattle:</...|      null|MINION|
|     Slawomir Maniak|  null|       true|   0|      null|    [40, 400, 5, 50]|     null|   null|They're only smil...|  null|                null|                null|EX1_607|         null|  Inner Rage|    null|[null,null,null,n...|    WARRIOR| null|   COMMON|EXPERT1|       null|              null|Deal $1 damage to...|      null| SPELL|
|          Andrew Hou|     4|       true|   7|      null|[1600, 3200, 400,...|     null|   null|With the help of ...|     2|                null|                null| AT_063|         null|     Acidmaw|    null|                null|     HUNTER|BEAST|LEGENDARY|    TGT|       null|              null|Whenever another ...|      null|MINION|
+--------------------+------+-----------+----+----------+--------------------+---------+-------+--------------------+------+--------------------+--------------------+-------+-------------+------------+--------+--------------------+-----------+-----+---------+-------+-----------+------------------+--------------------+----------+------+
only showing top 5 rows

#+end_example

#+BEGIN_SRC ipython :session :results output
  df.fillna()

  max_cost = df.agg({'cost': 'max'}).first()[0]
  max_attack = df.agg({'attack': 'max'}).first()[0]
  max_health = df.agg({'health': 'max'}).first()[0]


#+END_SRC
